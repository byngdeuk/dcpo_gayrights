#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a data frame
#'
#' @import rstan
#'
#' @export

library(rstan)

data1 <- gm1

dcpo <- function(x,
                 model_code = NULL,
                 seed = 324,
                 iter = 100,
                 cores = 1,
                 chains = 4)

### Delete these when turning into a function
seed <- 324
iter <- 600
cores <- 4
chains <- 4
x <- gm
###

dcpo_data <- list(  K=max(x$ccode),
                    T=max(x$tcode),
                    R=max(x$rcode),
                    N=length(x$y_r),
                    kk=x$ccode,
                    rr=x$rcode,
                    tt=x$tcode,
                    y_r=x$y_r,
                    n_r=x$n
)

dcpo_code <- '
  data {
      int<lower=1> K;     		// number of countries
      int<lower=1> R; 				// number of indicators
      int<lower=1> T; 				// number of years
      int<lower=1> N; 				// number of actual observations
      int<lower=1, upper=K> kk[N]; 	// country for observation n
      int<lower=1, upper=R> rr[N]; 	// indicator for observation n
      int<lower=1, upper=T> tt[N]; 	// year for observation n
      int<lower=0> y_r[N];    // number of respondents giving selected answer for observation n
      int<lower=0> n_r[N];    // total number of respondents for observation n
  }
  transformed data {
      int G[N-1];				// number of missing years until next observed country-year (G for "gap")
      for (n in 1:N-1) {
          G[n] <- tt[n+1] - tt[n] - 1;
      }
  }
  parameters {
      real<lower=0, upper=1> alpha[K, T]; // public opinion, minus (grand) mean public opinion
      real<lower=0, upper=1> mu_beta;  // mean public opinion
      real<lower=0> beta[R]; // position ("difficulty") of indicator r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using lambda))
      real<lower=0> gamma[R]; // discrimination of indicator r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using 1/alpha))
      real<lower=0> sigma_beta;   // scale of indicator positions (see Stan Development Team 2015, 61)
      real<lower=0> sigma_gamma;  // scale of indicator discriminations (see Stan Development Team 2015, 61)
      real<lower=0, upper=1> p[N]; // probability of individual respondent giving selected answer for observation n (see McGann 2014, 120)
      real<lower=0> sigma_k[K]; 	// country variance parameter (see Linzer and Stanton 2012, 12)
      real<lower=0, upper=10> b;  // "the degree of stochastic variation between question administrations" (McGann 2014, 122)
  }
  transformed parameters {
      real<lower=0, upper=1> m[K, T]; // expected proportion of population giving selected answer
      for (n in 1:N)
           m[kk[n], tt[n]] <- Phi((alpha[kk[n], tt[n]] - (beta[rr[n]] + mu_beta))/gamma[rr[n]]);
  }
  model {
      beta ~ normal(0, sigma_beta);
      gamma ~ lognormal(0, sigma_gamma);
      mu_beta ~ cauchy(0, 5);
      sigma_beta ~ cauchy(0, 5);
      sigma_gamma ~ cauchy(0, 5);
      b ~ uniform(0, 10);
      sigma_k ~ cauchy(0, 1);
      for (n in 1:N) {
          // actual number of respondents giving selected answer
          y_r[n] ~ binomial(n_r[n], p[n]);
          // individual probability of selected answer
          p[n] ~ beta(b*m[n]/(1 - m[n]), b);
          // prior for alpha for the next observed year by country as well as for all intervening missing years
          if (n < N) {
              if (tt[n] < T) {
                  for (g in 0:G[n]) {
                      alpha[kk[n], tt[n]+g+1] ~ normal(alpha[kk[n], tt[n]+g], sigma_k[kk[n]]);
                  }
              }
          }
      }
  }
'

out1 <- stan(model_code = dcpo_code,
             data = dcpo_data,
             seed = seed,
             iter = iter,
             cores = cores,
             chains = chains,
             control = list(max_treedepth = 15))

# lapply(get_sampler_params(out1, inc_warmup = TRUE),
#        summary, digits = 2)

#Chime
beep()
