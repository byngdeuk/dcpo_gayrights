#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a data frame
#'
#' @import rstan
#'
#' @export

library(rstan)

# data1 <- gm_a
#
# dcpo <- function(x,
#                  model_code = NULL,
#                  seed = 324,
#                  iter = 100,
#                  cores = 1,
#                  chains = 4)

# preprocessing
library(tidyverse)
library(rstan)
library(beepr)


### Delete these when turning into a function
seed <- 324
iter <- 500
chains <- 4
cores <- chains
x <- gm_a2
###

x <- x %>%
  mutate(ktcode = (ccode-1)*max(tcode)+tcode)

# t <- x %>%
#   group_by(ktcode) %>%
#   summarize(ccode = first(ccode),
#             tcode = first(tcode)) %>%
#   group_by(ccode) %>%
#   mutate(G = if_else(!is.na(lead(tcode)), lead(tcode) - tcode - 1, 0)) %>%
#   ungroup() %>%
#   mutate(mm = cumsum(if_else(!is.na(lag(G)), lag(G), 0))) %>%
#   select(ktcode, G, mm)
#
# x <- x %>%
#   left_join(t, by = "ktcode")

rq <- x %>%
  group_by(rcode) %>%
  summarize(rq = first(qcode),
            rcp = max(cutpoint))

dcpo_data <- list(  K=max(x$ccode),
                    T=max(x$tcode),
                    Q=max(x$qcode),
                    R=max(x$rcode),
                    N=length(x$y_r),
                    kk=x$ccode,
                    tt=x$tcode,
                    kktt=x$ktcode,
                    qq=x$qcode,
                    rr=x$rcode,
                    rq=rq$rq,
                    rcp=rq$rcp,
                    y_r=x$y_r,
                    n_r=x$n
                    # ,
                    # M=max(x$mm),
                    # mm=x$mm,
                    # G=x$G
)

# hierarchical_2pl lacks:
# X 1. aggregation
# X 2. time-series/random-walk priors
#   3. ordinal betas
# take them in that order
#
#  ignoring for the moment time-series by considering each
#   country-year an independent observation

dcpo_code <- '
  data {
    int<lower=1> K;     		// number of countries
    int<lower=1> T; 				// number of years
    int<lower=1> Q; 				// number of questions
    int<lower=1> R;         // number of question-cutpoints
    int<lower=1> N; 				// number of KTQR observations
    int<lower=1, upper=K> kk[N]; 	// country for observation n
    int<lower=1, upper=T> tt[N]; 	// year for observation n
    int<lower=1> kktt[N];         // country-year for observation n
    int<lower=1, upper=Q> qq[N];  // question for observation n
    int<lower=1, upper=R> rr[N]; 	// question-cutpoint for observation n
    int<lower=1, upper=R> rq[R];  // question for question-cutpoint r
    int<lower=1, upper=R> rcp[R]; // cutpoint for question-cutpoint r
    int<lower=0> y_r[N];    // number of respondents giving selected answer for observation n
    int<lower=0> n_r[N];    // total number of respondents for observation n
//    int<lower=0> M;    // number of KT observations without data (interpolated only)
//    int<lower=1, upper=K> km[M]; 	// country for missing observation nm
//    int<lower=1, upper=T> tm[M]; 	// year for missing observation nm
//    int<lower=0, upper=M> mm[N];    // number of missing KT preceding observation n
//    int<lower=0> G[N];              // number of missing years from observation until next observation in country k
  }
  parameters {
    vector[K*T] theta; // public opinion ("ability") for all kt
//    vector[M] theta_miss; // public opinion ("ability") for kt without data
    vector[2] xi[R]; // alpha/beta (discrimination/difficulty) pair vectors
    vector[2] mu; // vector for alpha/beta means
    vector<lower=0>[2] tau; // vector for alpha/beta residual sds
    cholesky_factor_corr[2] L_Omega; // Cholesky decomposition of the correlation matrix for log(alpha) and beta
    real<lower=0> sigma_theta[K]; 	// country variance parameter (see Linzer and Stanton 2012, 12)
//    real<lower=0, upper=1> tau[R]; // shift in difficulty across each cutpoint of each question
//    real<lower=0> sigma_tau;   // scale of cutpoint difficulties (cf. Stan Development Team 2015, 61)
  }
  transformed parameters {
//    real<lower=0, upper=1> m[N]; // expected probability of random individual giving selected answer
//    real<lower=0, upper=1> beta[R]; // position ("difficulty") of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using lambda))
//    beta = tau;
//    for (r in 2:R) {
//      if (rq[r]==rq[r-1])
//        beta[r] = beta[r-1] + (tau[r] * (1 - beta[r - 1]));
//    }
//    for (n in 1:N) {
//      m[n] = inv_logit((theta[kk[n], tt[n]] - beta[rr[n]]) / gamma[qq[n]]);
//    }

    vector[R] alpha; // discrimination of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using 1/alpha))
    vector[R] beta; // difficulty of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using lambda))
    for (r in 1:R) {
      alpha[r] = exp(xi[r,1]);
      beta[r] = xi[r,2];
    }
  }
  model {
    matrix[2,2] L_Sigma;
    L_Sigma = diag_pre_multiply(tau, L_Omega);
    for (r in 1:R) {
      xi[r] ~ multi_normal_cholesky(mu, L_Sigma);
    }
    sigma_theta ~ normal(0, .05);

    L_Omega ~ lkj_corr_cholesky(4);
    mu[1] ~ normal(0,1);
    tau[1] ~ exponential(.1);
    mu[2] ~ normal(0,5);
    tau[2] ~ exponential(.1);

    // random-walk prior for theta
    for (k in 1:K) {
      theta[(k-1)*T+1] ~ normal(0, 1);
      for (t in 2:T) {
        theta[(k-1)*T+t] ~ normal(theta[(k-1)*T+t-1], sigma_theta[k]);
      }
    }

    y_r ~ binomial_logit(n_r, alpha[rr] .* (theta[kktt] - beta[rr]));

  }
  generated quantities {
    corr_matrix[2] Omega;
    Omega = multiply_lower_tri_self_transpose(L_Omega);
  }
'

start <- proc.time()
out1 <- stan(model_code = dcpo_code,
             data = dcpo_data,
             seed = seed,
             iter = iter,
             cores = cores,
             chains = chains,
             control = list(max_treedepth = 20,
                            adapt_delta = .8)) # this is the default, btw
runtime <- proc.time() - start
runtime/60

lapply(get_sampler_params(out1, inc_warmup = FALSE),
       summary, digits = 2)

#Chime
beep()
