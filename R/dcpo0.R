#' Estimate Dynamic Comparative Public Opinion
#'
#' \code{dcpo} uses diverse survey data to estimate public opinion across countries and over time.
#'
#' @param df a data frame of survey items and marginals generated by \code{dcpo_setup}
#
#' @details \code{dcpo_setup}, when passed a data frame of survey items, collects the
#' responses and formats them for use with the \code{dcpo} function.
#'
#' @return a data frame
#'
#' @import rstan
#'
#' @export

library(rstan)

# data1 <- gm_a
#
# dcpo <- function(x,
#                  model_code = NULL,
#                  seed = 324,
#                  iter = 100,
#                  cores = 1,
#                  chains = 4)

# preprocessing
library(tidyverse)
library(rstan)
library(beepr)

# to do
# - full aggregate IRT?
# - robust dynamic priors (per Reuning2016)?
# - explicitly ordinal betas?

### Delete these when turning into a function
seed <- 324
iter <- 500
chains <- 4
cores <- chains
x <- gm
###

x <- x %>%
  mutate(ktcode = (ccode-1)*max(tcode)+tcode)

rq <- x %>%
  group_by(rcode) %>%
  summarize(rq = first(qcode),
            rcp = max(cutpoint))

dcpo_data <- list(  K=max(x$ccode),
                    T=max(x$tcode),
                    Q=max(x$qcode),
                    R=max(x$rcode),
                    N=length(x$y_r),
                    kk=x$ccode,
                    tt=x$tcode,
                    kktt=x$ktcode,
                    qq=x$qcode,
                    rr=x$rcode,
                    rq=rq$rq,
                    rcp=rq$rcp,
                    y_r=x$y_r,
                    n_r=x$n
)

dcpo_code <- '
  data {
    int<lower=1> K;     		// number of countries
    int<lower=1> T; 				// number of years
    int<lower=1> Q; 				// number of questions
    int<lower=1> R;         // number of question-cutpoints
    int<lower=1> N; 				// number of KTQR observations
    int<lower=1, upper=K> kk[N]; 	// country for observation n
    int<lower=1, upper=T> tt[N]; 	// year for observation n
    int<lower=1> kktt[N];         // country-year for observation n
    int<lower=1, upper=Q> qq[N];  // question for observation n
    int<lower=1, upper=R> rr[N]; 	// question-cutpoint for observation n
    int<lower=1, upper=R> rq[R];  // question for question-cutpoint r
    int<lower=1, upper=R> rcp[R]; // cutpoint for question-cutpoint r
    int<lower=0> y_r[N];    // number of respondents giving selected answer for observation n
    int<lower=0> n_r[N];    // total number of respondents for observation n
  }
  parameters {
    vector[K*T] theta; // public opinion ("ability") for all kt
    vector[2] xi[R]; // alpha/beta (discrimination/difficulty) pair vectors
    vector[2] mu; // vector for alpha/beta means
    vector<lower=0>[2] tau; // vector for alpha/beta residual sds
    cholesky_factor_corr[2] L_Omega; // Cholesky decomposition of the correlation matrix for log(alpha) and beta
    real<lower=0> sigma_theta[K]; 	// country variance parameter (see Linzer and Stanton 2012, 12)
  }
  transformed parameters {
    vector[R] alpha; // discrimination of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using 1/alpha))
    vector[R] beta; // difficulty of question-cutpoint r (see Stan Development Team 2015, 61; Gelman and Hill 2007, 314-320; McGann 2014, 118-120 (using lambda))
    for (r in 1:R) {
      alpha[r] = exp(xi[r,1]);
      beta[r] = exp(xi[r,2]);
      if (r > 1)
        if (rq[r]==rq[r-1])
          beta[r] = beta[r-1] + beta[r];
    }
  }
  model {
    matrix[2,2] L_Sigma;
    L_Sigma = diag_pre_multiply(tau, L_Omega);
    for (r in 1:R) {
      xi[r] ~ multi_normal_cholesky(mu, L_Sigma);
    }
    sigma_theta ~ normal(0, .05);

    L_Omega ~ lkj_corr_cholesky(4);
    mu[1] ~ normal(0, 1);
    tau[1] ~ exponential(.1);
    mu[2] ~ normal(0, 1);
    tau[2] ~ exponential(.1);

    // random-walk prior for theta
    for (k in 1:K) {
      theta[(k-1)*T+1] ~ normal(0, 1);
      for (t in 2:T) {
        theta[(k-1)*T+t] ~ normal(theta[(k-1)*T+t-1], sigma_theta[k]);
      }
    }

    y_r ~ binomial_logit(n_r, alpha[rr] .* (theta[kktt] - beta[rr]));

  }
  generated quantities {
    corr_matrix[2] Omega;
    Omega = multiply_lower_tri_self_transpose(L_Omega);
  }
'

start <- proc.time()
out1 <- stan(model_code = dcpo_code,
             data = dcpo_data,
             seed = seed,
             iter = iter,
             cores = cores,
             chains = chains,
             control = list(max_treedepth = 20))
runtime <- proc.time() - start
runtime/60

lapply(get_sampler_params(out1, inc_warmup = FALSE),
       summary, digits = 2)

#Chime
beep()
